<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Screen Recorder</title>
    <script src="https://api.apowersoft.com/screen-recorder?lang=en" defer></script>
    <style>
        /* General Styles */
        :root {
            --bg-color: #121212;
            --text-color: white;
            --card-bg: #1e1e1e;
            --button-bg: #4CAF50;
            --button-hover: #45a049;
            --record-button: #f44336;
            --record-button-hover: #d32f2f;
            --toggle-bg: #007bff;
            --toggle-hover: #0056b3;
        }

        [data-theme="light"] {
            --bg-color: #f4f4f4;
            --text-color: #121212;
            --card-bg: white;
            --button-bg: #008cba;
            --button-hover: #0078a0;
            --record-button: #ff4c4c;
            --record-button-hover: #d32f2f;
            --toggle-bg: #ffcc00;
            --toggle-hover: #e6b800;
        }

        body {
            font-family: 'Arial', sans-serif;
            text-align: center;
            margin: 0;
            background: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
        }

        .screen-recorder-container {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            width: 90%;
            max-width: 500px;
            text-align: center;
        }

        h2 {
            margin-bottom: 10px;
        }

        select, button {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: none;
            margin: 5px 0;
        }

        button {
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }

        #startRecording {
            background: var(--button-bg);
            color: white;
        }

        #startRecording:hover {
            background: var(--button-hover);
        }

        #stopRecording {
            background: var(--record-button);
            color: white;
            display: none;
        }

        #stopRecording:hover {
            background: var(--record-button-hover);
        }

        #toggleTheme {
            background: var(--toggle-bg);
            color: white;
        }

        #toggleTheme:hover {
            background: var(--toggle-hover);
        }

        .status {
            margin-top: 10px;
            font-weight: bold;
            font-size: 14px;
        }

        video {
            margin-top: 10px;
            width: 100%;
            display: none;
        }

        #downloadLink {
            display: none;
            text-decoration: none;
            padding: 10px;
            background: var(--toggle-bg);
            color: white;
            border-radius: 5px;
            margin-top: 10px;
            transition: background 0.3s;
        }

        #downloadLink:hover {
            background: var(--toggle-hover);
        }

        /* Floating Preview */
        .floating-preview {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 150px;
            border-radius: 10px;
            box-shadow: 0px 0px 5px rgba(0,0,0,0.5);
            background: black;
            overflow: hidden;
            display: none;
        }

        .floating-preview video {
            width: 100%;
        }

        .floating-preview span {
            position: absolute;
            top: 5px;
            right: 10px;
            cursor: pointer;
            background: red;
            color: white;
            padding: 3px 8px;
            border-radius: 50%;
            font-weight: bold;
        }

        .processing-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }

        .processing-content {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .progress-bar {
            width: 300px;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress {
            width: 0%;
            height: 100%;
            background: var(--button-bg);
            transition: width 0.3s;
        }

        .export-options {
            margin: 15px 0;
            padding: 10px;
            background: rgba(0,0,0,0.1);
            border-radius: 8px;
        }

        .export-options select {
            width: 100%;
            margin: 5px 0;
            padding: 8px;
            border-radius: 4px;
        }

        .quality-settings {
            margin: 15px 0;
            padding: 15px;
            background: rgba(0,0,0,0.05);
            border-radius: 8px;
        }

        .quality-section {
            margin-bottom: 15px;
        }

        .quality-section h3 {
            margin-bottom: 10px;
            font-size: 16px;
        }

        .quality-select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border-radius: 4px;
            border: 1px solid var(--button-bg);
        }

        .custom-quality-options {
            padding: 10px;
            background: rgba(0,0,0,0.05);
            border-radius: 4px;
            margin-top: 10px;
        }

        .custom-quality-options label {
            display: block;
            margin-bottom: 8px;
        }

        .custom-quality-options input,
        .custom-quality-options select {
            width: 100%;
            padding: 6px;
            margin-top: 4px;
            border-radius: 4px;
            border: 1px solid var(--button-bg);
        }

        .audio-meters {
            margin-top: 10px;
        }

        .meter-container {
            margin-bottom: 8px;
        }

        .audio-meter {
            height: 10px;
            background: #ddd;
            border-radius: 5px;
            overflow: hidden;
        }

        .audio-meter::before {
            content: '';
            display: block;
            height: 100%;
            width: 0%;
            background: var(--button-bg);
            transition: width 0.1s ease;
        }

        #estimated-size {
            font-size: 12px;
            color: var(--text-color);
            opacity: 0.8;
            margin-top: 5px;
        }

        /* Secondary Panel Styles */
        .secondary-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--card-bg);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            width: 300px;
            z-index: 1000;
            display: none;
        }

        .precision-timer-section,
        .soundboard-section {
            margin-bottom: 20px;
        }

        .timer-display {
            font-family: monospace;
            font-size: 24px;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0,0,0,0.1);
            border-radius: 5px;
            text-align: center;
        }

        .timer-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }

        .lap-times {
            max-height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }

        .sound-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }

        .sound-button {
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: var(--button-bg);
            color: white;
            cursor: pointer;
            transition: background 0.3s;
        }

        .sound-button:hover {
            background: var(--button-hover);
        }

        .bluetooth-controls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .bluetooth-status {
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
        }

        .audio-controls {
            margin-top: 15px;
        }

        .volume-control {
            margin-bottom: 15px;
        }

        .volume-control label {
            display: block;
            margin-bottom: 5px;
        }

        .volume-control input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .audio-meter {
            height: 10px;
            background: #ddd;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }

        .audio-meter .meter-fill {
            height: 100%;
            width: 0%;
            background: var(--button-bg);
            transition: width 0.1s ease;
        }
    </style>
</head>
<body>
    <div class="screen-recorder-container">
        <h2>Apowersoft Screen Recorder</h2>

        <button id="toggleTheme">Toggle Dark/Light Mode</button>

        <div class="quality-settings">
            <div class="quality-section">
                <h3>Video Settings</h3>
                <select id="video-quality" class="quality-select" title="Video Quality">
                    <option value="hd">HD</option>
                    <option value="sd">SD</option>
                </select>
                <div class="custom-quality-options" style="display: none;">
                    <label>Frame Rate:
                        <input type="number" id="custom-framerate" min="1" max="60" value="30">
                    </label>
                    <label>Resolution:
                        <select id="custom-resolution">
                            <option value="3840x2160">4K (3840x2160)</option>
                            <option value="1920x1080">1080p (1920x1080)</option>
                            <option value="1280x720">720p (1280x720)</option>
                            <option value="854x480">480p (854x480)</option>
                            <option value="640x360">360p (640x360)</option>
                        </select>
                    </label>
                    <label>Bitrate (Mbps):
                        <input type="number" id="custom-bitrate" min="0.1" max="20" step="0.1" value="2.5">
                    </label>
                </div>
            </div>

            <div class="quality-section">
                <h3>Audio Settings</h3>
                <select id="audio-source" class="quality-select" title="Audio Source">
                    <option value="both">Microphone + System Audio</option>
                    <option value="microphone">Microphone Only</option>
                    <option value="system">System Audio Only</option>
                    <option value="none">No Audio</option>
                </select>
                
                <div class="audio-controls">
                    <div class="volume-control">
                        <label for="mic-volume">Microphone Volume</label>
                        <input type="range" id="mic-volume" min="0" max="100" value="100" title="Microphone Volume Control">
                        <div id="mic-meter" class="audio-meter"></div>
                    </div>
                    <div class="volume-control">
                        <label for="system-volume">System Audio Volume</label>
                        <input type="range" id="system-volume" min="0" max="100" value="100" title="System Audio Volume Control">
                        <div id="system-meter" class="audio-meter"></div>
                    </div>
                </div>
            </div>
        </div>

        <button id="startRecording">Start Recording</button>
        <button id="stopRecording">Stop Recording</button>
        <button id="markTime">Mark Key Moment</button>

        <div class="status" id="recordingStatus">Ready to Record</div>

        <video id="recordedVideo" controls></video>
        <a id="downloadLink">Download Recording</a>
    </div>

    <div class="floating-preview">
        <span onclick="closePreview()">×</span>
        <video id="previewVideo" autoplay muted></video>
    </div>

    <div class="secondary-panel">
        <div class="precision-timer-section">
            <h3>Precision Timer</h3>
            <div class="timer-display">00:00:00.000</div>
            <div class="timer-controls">
                <button id="timerStart">Start</button>
                <button id="timerStop">Stop</button>
                <button id="timerLap">Lap</button>
                <button id="timerReset">Reset</button>
            </div>
            <div class="lap-times"></div>
        </div>

        <div class="soundboard-section">
            <h3>Soundboard</h3>
            <div class="sound-buttons">
                ${Object.entries(SOUND_EFFECTS).map(([key, sound]) => `
                    <button class="sound-button" data-sound="${key}">
                        ${sound.label}
                    </button>
                `).join('')}
            </div>
            <div class="bluetooth-controls">
                <button id="bluetoothConnect">
                    Connect Bluetooth Audio
                </button>
                <div class="bluetooth-status">Not Connected</div>
            </div>
        </div>
    </div>

    <script>
        let recorder, stream;
        let recordedChunks = [];
        let markers = [];
        let darkMode = true;
        let recordingStartTime;
        let recordingDuration;
        let recordingInterval;
        
        // Constants
        const MAX_RECORDING_DURATION = 3600; // 1 hour in seconds
        const MIN_DISK_SPACE = 500 * 1024 * 1024; // 500MB in bytes
        const CHUNK_SIZE = 1000; // 1 second chunks
        
        // Analytics data
        const analytics = {
            recordingsStarted: 0,
            recordingsCompleted: 0,
            totalDuration: 0,
            errors: [],
            lastRecordingSize: 0
        };

        // Logger
        const logger = {
            info: (message) => {
                console.log(`[INFO][${new Date().toISOString()}] ${message}`);
            },
            error: (message, error) => {
                console.error(`[ERROR][${new Date().toISOString()}] ${message}`, error);
                analytics.errors.push({ timestamp: new Date(), message, error: error?.message });
            },
            warn: (message) => {
                console.warn(`[WARN][${new Date().toISOString()}] ${message}`);
            }
        };

        // Initialize soundboard with proper audio handling
        const SOUND_EFFECTS = {
            beep: { 
                label: 'Beep',
                duration: 0.5,
                frequency: 440 // A4 note
            },
            click: { 
                label: 'Click',
                duration: 0.2,
                frequency: 880 // A5 note
            },
            ding: { 
                label: 'Ding',
                duration: 0.8,
                frequency: 523.25 // C5 note
            }
        };

        class SoundboardManager {
            constructor() {
                this.audioContext = null;
                this.soundBuffers = {};
                this.isInitialized = false;
                this.outputDevice = null;
            }

            async initialize() {
                if (this.isInitialized) return;

                try {
                    // Create audio context with proper options for system audio output
                    const contextOptions = {
                        latencyHint: 'interactive',
                        sampleRate: 48000
                    };
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)(contextOptions);

                    // Get list of available audio output devices
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const audioOutputs = devices.filter(device => device.kind === 'audiooutput');
                    
                    // Log available audio outputs for debugging
                    logger.info('Available audio outputs:', audioOutputs.map(d => `${d.label} (${d.deviceId})`));

                    // Try to get the default audio output device
                    if (audioOutputs.length > 0) {
                        const defaultDevice = audioOutputs.find(d => d.deviceId === 'default') || audioOutputs[0];
                        await this.setAudioOutput(defaultDevice.deviceId);
                    }

                    // Create sound buffers
                    for (const [key, sound] of Object.entries(SOUND_EFFECTS)) {
                        const buffer = await this.createSoundBuffer(sound);
                        this.soundBuffers[key] = buffer;
                    }

                    // Add device change listener
                    navigator.mediaDevices.addEventListener('devicechange', async () => {
                        await this.handleDeviceChange();
                    });

                    this.isInitialized = true;
                    logger.info('Soundboard initialized successfully');
                } catch (error) {
                    logger.error('Error initializing soundboard', error);
                    throw error;
                }
            }

            async handleDeviceChange() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const audioOutputs = devices.filter(device => device.kind === 'audiooutput');
                    
                    // If current output device is not in the list, switch to default
                    if (this.outputDevice && !audioOutputs.find(d => d.deviceId === this.outputDevice)) {
                        const defaultDevice = audioOutputs.find(d => d.deviceId === 'default') || audioOutputs[0];
                        if (defaultDevice) {
                            await this.setAudioOutput(defaultDevice.deviceId);
                        }
                    }
                } catch (error) {
                    logger.error('Error handling device change', error);
                }
            }

            async setAudioOutput(deviceId) {
                try {
                    // For browsers that support setSinkId
                    if (typeof HTMLAudioElement.prototype.setSinkId === 'function') {
                        // Create a dummy audio element to set the sink ID
                        const audio = new Audio();
                        await audio.setSinkId(deviceId);
                        this.outputDevice = deviceId;
                        logger.info(`Audio output set to device: ${deviceId}`);
                    } else {
                        // Fallback for browsers that don't support setSinkId
                        this.outputDevice = 'default';
                        logger.warn('setSinkId not supported, using default audio output');
                    }
                } catch (error) {
                    logger.error('Error setting audio output', error);
                    this.outputDevice = 'default';
                }
            }

            async createSoundBuffer({ duration, frequency = 440 }) {
                const sampleRate = this.audioContext.sampleRate;
                const buffer = this.audioContext.createBuffer(2, duration * sampleRate, sampleRate);
                
                // Create stereo sound (2 channels)
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = buffer.getChannelData(channel);
                    for (let i = 0; i < buffer.length; i++) {
                        // Create a more complex waveform with harmonics
                        const t = i / sampleRate;
                        const fundamental = Math.sin(2 * Math.PI * frequency * t);
                        const harmonic1 = Math.sin(2 * Math.PI * (frequency * 2) * t) * 0.5;
                        const harmonic2 = Math.sin(2 * Math.PI * (frequency * 3) * t) * 0.25;
                        
                        channelData[i] = (fundamental + harmonic1 + harmonic2) *
                            Math.exp(-5 * i / buffer.length); // Add decay
                    }
                }
                
                return buffer;
            }

            async playSound(soundKey) {
                if (!this.isInitialized || !this.soundBuffers[soundKey]) {
                    logger.warn(`Sound ${soundKey} not initialized`);
                    return;
                }

                try {
                    // Resume audio context if it's suspended
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }

                    const source = this.audioContext.createBufferSource();
                    const gainNode = this.audioContext.createGain();
                    const stereoPanner = this.audioContext.createStereoPanner();
                    
                    source.buffer = this.soundBuffers[soundKey];
                    
                    // Create audio processing chain
                    source
                        .connect(gainNode)
                        .connect(stereoPanner)
                        .connect(this.audioContext.destination);

                    // Add slight stereo effect
                    stereoPanner.pan.value = Math.random() * 0.4 - 0.2; // Random pan between -0.2 and 0.2
                    
                    // Start the sound
                    source.start();
                    logger.info(`Playing sound: ${soundKey}`);
                } catch (error) {
                    logger.error(`Error playing sound: ${soundKey}`, error);
                }
            }
        }

        class BluetoothAudioManager {
            constructor() {
                this.device = null;
                this.gattServer = null;
                this.audioService = null;
                this.isConnecting = false;
            }

            async connect() {
                if (this.isConnecting) return false;
                this.isConnecting = true;

                try {
                    if (!navigator.bluetooth) {
                        throw new Error('Bluetooth API not available');
                    }

                    // Request device with audio capabilities
                    this.device = await navigator.bluetooth.requestDevice({
                        filters: [
                            { services: ['0000110b-0000-1000-8000-00805f9b34fb'] } // A2DP Sink service
                        ],
                        optionalServices: ['battery_service']
                    });

                    // Connect to GATT server
                    this.gattServer = await this.device.gatt.connect();
                    
                    // Try to get battery service if available
                    try {
                        const batteryService = await this.gattServer.getPrimaryService('battery_service');
                        const batteryLevel = await batteryService.getCharacteristic('battery_level');
                        const value = await batteryLevel.readValue();
                        logger.info(`Connected device battery level: ${value.getUint8(0)}%`);
                    } catch (e) {
                        logger.warn('Battery service not available', e);
                    }

                    this.device.addEventListener('gattserverdisconnected', this.handleDisconnection.bind(this));
                    
                    this.isConnecting = false;
                    return true;
                } catch (error) {
                    logger.error('Bluetooth connection error', error);
                    this.isConnecting = false;
                    return false;
                }
            }

            handleDisconnection() {
                logger.warn('Bluetooth device disconnected');
                this.gattServer = null;
                this.audioService = null;
                
                // Update UI
                const statusElement = document.querySelector('.bluetooth-status');
                if (statusElement) {
                    statusElement.textContent = 'Disconnected';
                    statusElement.style.color = 'var(--record-button)';
                }
            }

            disconnect() {
                if (this.gattServer && this.gattServer.connected) {
                    this.gattServer.disconnect();
                }
                this.device = null;
                this.gattServer = null;
                this.audioService = null;
            }

            isConnected() {
                return this.gattServer && this.gattServer.connected;
            }
        }

        // Initialize managers
        const soundboardManager = new SoundboardManager();
        const bluetoothManager = new BluetoothAudioManager();

        // Add precision timer class
        class PrecisionTimer {
            constructor() {
                this.startTime = 0;
                this.offset = 0;
                this.isRunning = false;
                this.intervals = [];
                this.laps = [];
            }

            start() {
                if (!this.isRunning) {
                    this.startTime = performance.now() - this.offset;
                    this.isRunning = true;
                }
            }

            stop() {
                if (this.isRunning) {
                    this.offset = performance.now() - this.startTime;
                    this.isRunning = false;
                }
            }

            reset() {
                this.offset = 0;
                this.laps = [];
                this.intervals = [];
            }

            lap() {
                const lapTime = this.getTime();
                this.laps.push(lapTime);
                return lapTime;
            }

            getTime() {
                return this.isRunning ? 
                    performance.now() - this.startTime : 
                    this.offset;
            }

            getFormattedTime(precision = 3) {
                const time = this.getTime();
                const ms = time % 1000;
                const s = Math.floor((time / 1000) % 60);
                const m = Math.floor((time / (1000 * 60)) % 60);
                const h = Math.floor(time / (1000 * 60 * 60));

                return `${h.toString().padStart(2, '0')}:${
                    m.toString().padStart(2, '0')}:${
                    s.toString().padStart(2, '0')}.${
                    ms.toFixed(precision).slice(2)}`;
            }
        }

        // Check available disk space
        async function checkDiskSpace() {
            try {
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const { quota, usage } = await navigator.storage.estimate();
                    const available = quota - usage;
                    if (available < MIN_DISK_SPACE) {
                        throw new Error(`Insufficient disk space. Need at least ${MIN_DISK_SPACE / (1024 * 1024)}MB`);
                    }
                    return true;
                }
                logger.warn('Storage estimation API not available');
                return true;
            } catch (error) {
                logger.error('Error checking disk space', error);
                throw error;
            }
        }

        // Check and request permissions
        async function checkAndRequestPermissions() {
            try {
                const permissions = {
                    microphone: false,
                    camera: false,
                    displayMedia: false
                };

                // Check microphone permission
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        stream.getTracks().forEach(track => track.stop());
                        permissions.microphone = true;
                    } catch (e) {
                        logger.warn('Microphone permission denied', e);
                    }
                }

                // Check camera permission (for potential future use)
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                        stream.getTracks().forEach(track => track.stop());
                        permissions.camera = true;
                    } catch (e) {
                        logger.warn('Camera permission denied', e);
                    }
                }

                // Check display capture permission
                if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                    permissions.displayMedia = true;
                }

                return permissions;
            } catch (error) {
                logger.error('Error checking permissions', error);
                throw error;
            }
        }

        // Compression worker for large recordings
        const compressionWorker = new Worker(URL.createObjectURL(new Blob([`
            self.onmessage = async function(e) {
                try {
                    const { chunks, quality } = e.data;
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    
                    // Create compressed version
                    const compressedBlob = await new Promise((resolve) => {
                        const canvas = new OffscreenCanvas(1280, 720);
                        const ctx = canvas.getContext('2d');
                        const video = new Video();
                        
                        video.src = URL.createObjectURL(blob);
                        video.onloadedmetadata = () => {
                            const stream = canvas.captureStream(30);
                            const recorder = new MediaRecorder(stream, {
                                videoBitsPerSecond: quality === 'hd' ? 1500000 : 800000
                            });
                            
                            const compressedChunks = [];
                            recorder.ondataavailable = e => compressedChunks.push(e.data);
                            recorder.onstop = () => resolve(new Blob(compressedChunks, { type: 'video/webm' }));
                            
                            video.play();
                            recorder.start();
                            
                            video.onended = () => recorder.stop();
                        };
                    });
                    
                    self.postMessage({ success: true, blob: compressedBlob });
                } catch (error) {
                    self.postMessage({ success: false, error: error.message });
                }
            };
        `], { type: 'text/javascript' })));

        // Session management
        const session = {
            id: crypto.randomUUID(),
            startTime: new Date(),
            recordings: [],
            
            addRecording(duration, size, markers) {
                this.recordings.push({
                    id: crypto.randomUUID(),
                    timestamp: new Date(),
                    duration,
                    size,
                    markers
                });
                
                // Save session data
                localStorage.setItem('recordingSession', JSON.stringify({
                    id: this.id,
                    startTime: this.startTime,
                    recordings: this.recordings
                }));
            }
        };

        // Enhanced cleanup function
        async function cleanup() {
            try {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                if (recorder) {
                    if (recorder.state !== 'inactive') {
                        recorder.stop();
                    }
                }
                
                // Clear data
                recordedChunks = [];
                markers = [];
                if (recordingInterval) {
                    clearInterval(recordingInterval);
                }
                
                // Reset UI
                document.getElementById("recordingStatus").innerText = "Ready to Record";
                document.getElementById("startRecording").style.display = "inline-block";
                document.getElementById("stopRecording").style.display = "none";
                document.getElementById("markTime").disabled = true;
                document.querySelector(".floating-preview").style.display = "none";
                
                // Clear preview
                const previewVideo = document.getElementById("previewVideo");
                if (previewVideo.srcObject) {
                    previewVideo.srcObject = null;
                }
                
                logger.info('Cleanup completed successfully');
            } catch (error) {
                logger.error('Error during cleanup', error);
            }
        }

        // Initialize the application
        async function initializeApp() {
            try {
                // Check HTTPS
                if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
                    throw new Error('HTTPS is required for screen recording');
                }
                
                // Check browser compatibility
                if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                    throw new Error('Screen recording is not supported in this browser');
                }
                
                // Check permissions
                const permissions = await checkAndRequestPermissions();
                logger.info('Permissions status:', permissions);
                
                // Check disk space
                await checkDiskSpace();
                
                // Load previous session if exists
                const savedSession = localStorage.getItem('recordingSession');
                if (savedSession) {
                    const sessionData = JSON.parse(savedSession);
                    session.recordings = sessionData.recordings || [];
                }
                
                // Initialize UI state
                document.body.setAttribute("data-theme", darkMode ? "dark" : "light");
                
                logger.info('Application initialized successfully');
                return true;
            } catch (error) {
                logger.error('Error initializing application', error);
                document.getElementById("recordingStatus").innerText = `Error: ${error.message}`;
                return false;
            }
        }

        // Format recording for download
        async function prepareRecordingForDownload(chunks, quality) {
            try {
                // Create initial blob
                const blob = new Blob(chunks, { type: 'video/webm' });
                
                // Compress if file is too large (>100MB)
                if (blob.size > 100 * 1024 * 1024) {
                    return new Promise((resolve, reject) => {
                        compressionWorker.onmessage = (e) => {
                            if (e.data.success) {
                                resolve(e.data.blob);
                            } else {
                                reject(new Error(e.data.error));
                            }
                        };
                        compressionWorker.postMessage({ chunks, quality });
                    });
                }
                
                return blob;
            } catch (error) {
                logger.error('Error preparing recording for download', error);
                throw error;
            }
        }

        // Enhanced recording preview
        function showRecordingPreview(blob) {
            const previewModal = document.createElement('div');
            previewModal.className = 'preview-modal';
            previewModal.innerHTML = `
                <div class="preview-content">
                    <video controls src="${URL.createObjectURL(blob)}"></video>
                    <div class="export-options">
                        <h3>Export Options</h3>
                        <select id="exportFormat">
                            <option value="webm">WebM (Best Quality)</option>
                            <option value="mp4">MP4 (Most Compatible)</option>
                            <option value="gif">GIF (Small Size)</option>
                        </select>
                        <select id="exportQuality">
                            <option value="0.8">High Quality</option>
                            <option value="0.6">Medium Quality</option>
                            <option value="0.4">Low Quality (Smaller Size)</option>
                        </select>
                    </div>
                    <div class="preview-controls">
                        <button onclick="saveRecording(
                            document.getElementById('exportFormat').value,
                            parseFloat(document.getElementById('exportQuality').value)
                        )">Save</button>
                        <button onclick="discardRecording()">Discard</button>
                    </div>
                </div>
            `;
            document.body.appendChild(previewModal);
        }

        // Initialize the application
        initializeApp().then(success => {
            if (!success) {
                document.getElementById("startRecording").disabled = true;
            }
        });

        // Handle page unload
        window.addEventListener('beforeunload', (e) => {
            if (recorder && recorder.state !== 'inactive') {
                e.preventDefault();
                e.returnValue = 'Recording in progress. Are you sure you want to leave?';
            }
        });

        // Theme toggle
        document.getElementById("toggleTheme").addEventListener("click", function() {
            darkMode = !darkMode;
            document.body.setAttribute("data-theme", darkMode ? "dark" : "light");
        });

        // Start recording
        document.getElementById("startRecording").addEventListener("click", async function() {
            try {
                // Clear previous recording data
                await cleanup();
                
                // Check disk space
                await checkDiskSpace();
                
                const videoQuality = document.getElementById("video-quality").value;
                const audioSource = document.getElementById("audio-source").value;
                const micVolume = document.getElementById("mic-volume").value / 100;
                const systemVolume = document.getElementById("system-volume").value / 100;

                // Update UI
                document.getElementById("recordingStatus").innerText = "Initializing...";
                document.getElementById("markTime").disabled = true;

                // Set up audio context for volume monitoring
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Get display media stream
                stream = await navigator.mediaDevices.getDisplayMedia({
                    video: { 
                        frameRate: videoQuality === "hd" ? 30 : 15,
                        width: videoQuality === "hd" ? 1920 : 1280,
                        height: videoQuality === "hd" ? 1080 : 720
                    },
                    audio: true // Always request system audio
                });

                // Handle audio sources
                let audioStream = null;
                if (audioSource === "both" || audioSource === "microphone") {
                    try {
                        audioStream = await navigator.mediaDevices.getUserMedia({ 
                            audio: {
                                echoCancellation: true,
                                noiseSuppression: true,
                                autoGainControl: true
                            }
                        });
                    } catch (e) {
                        logger.warn('Could not get microphone access', e);
                        if (audioSource === "microphone") {
                            throw new Error("Microphone access is required but not available");
                        }
                    }
                }

                // Set up audio processing
                if (audioStream) {
                    const micSource = audioContext.createMediaStreamSource(audioStream);
                    const micGain = audioContext.createGain();
                    const micAnalyser = audioContext.createAnalyser();
                    
                    micGain.gain.value = micVolume;
                    micSource.connect(micGain).connect(micAnalyser);
                    
                    // Update microphone meter
                    const micMeter = document.getElementById("mic-meter");
                    const micData = new Uint8Array(micAnalyser.frequencyBinCount);
                    
                    function updateMicMeter() {
                        if (recorder && recorder.state === "recording") {
                            micAnalyser.getByteFrequencyData(micData);
                            const volume = Math.max(...micData) / 255 * 100;
                            micMeter.innerHTML = `<div class="meter-fill" style="width: ${volume}%"></div>`;
                            requestAnimationFrame(updateMicMeter);
                        }
                    }
                    updateMicMeter();
                }

                // Set up system audio processing
                const systemSource = audioContext.createMediaStreamSource(stream);
                const systemGain = audioContext.createGain();
                const systemAnalyser = audioContext.createAnalyser();
                
                systemGain.gain.value = systemVolume;
                systemSource.connect(systemGain).connect(systemAnalyser);
                
                // Update system audio meter
                const systemMeter = document.getElementById("system-meter");
                const systemData = new Uint8Array(systemAnalyser.frequencyBinCount);
                
                function updateSystemMeter() {
                    if (recorder && recorder.state === "recording") {
                        systemAnalyser.getByteFrequencyData(systemData);
                        const volume = Math.max(...systemData) / 255 * 100;
                        systemMeter.innerHTML = `<div class="meter-fill" style="width: ${volume}%"></div>`;
                        requestAnimationFrame(updateSystemMeter);
                    }
                }
                updateSystemMeter();

                // Combine audio streams if necessary
                let finalStream = stream;
                if (audioStream) {
                    const audioTracks = [];
                    if (audioSource !== "microphone") {
                        audioTracks.push(stream.getAudioTracks()[0]);
                    }
                    if (audioSource !== "system") {
                        audioTracks.push(audioStream.getAudioTracks()[0]);
                    }
                    
                    finalStream = new MediaStream([
                        ...stream.getVideoTracks(),
                        ...audioTracks
                    ]);
                }
                
                // Set up MediaRecorder with error handling
                try {
                    recorder = new MediaRecorder(finalStream, { 
                        mimeType: "video/webm;codecs=vp9,opus",
                        videoBitsPerSecond: videoQuality === "hd" ? 2500000 : 1000000
                    });
                } catch (e) {
                    recorder = new MediaRecorder(finalStream, { mimeType: "video/webm" });
                }

                // Show preview
                document.querySelector(".floating-preview").style.display = "block";
                document.getElementById("previewVideo").srcObject = stream;

                // Handle data
                recorder.ondataavailable = event => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                        
                        // Check recording duration
                        if (recordingDuration >= MAX_RECORDING_DURATION) {
                            logger.warn('Maximum recording duration reached');
                            recorder.stop();
                        }
                    }
                };
                
                // Handle errors
                recorder.onerror = (event) => {
                    logger.error('Recording error', event.error);
                    cleanup();
                    document.getElementById("recordingStatus").innerText = "Recording failed: " + event.error;
                };

                // Handle recording stop
                recorder.onstop = async () => {
                    try {
                        clearInterval(recordingInterval);
                        
                        // Clean up old object URL
                        const oldVideo = document.getElementById("recordedVideo");
                        if (oldVideo.src) {
                            URL.revokeObjectURL(oldVideo.src);
                        }

                        // Prepare recording
                        const blob = await prepareRecordingForDownload(recordedChunks, videoQuality);
                        const url = URL.createObjectURL(blob);

                        // Update analytics
                        analytics.recordingsCompleted++;
                        analytics.lastRecordingSize = blob.size;
                        analytics.totalDuration += recordingDuration;

                        // Save to session
                        session.addRecording(recordingDuration, blob.size, markers);

                        // Show preview
                        showRecordingPreview(blob);

                        // Update UI
                        document.getElementById("recordedVideo").src = url;
                        document.getElementById("recordedVideo").style.display = "block";
                        
                        document.getElementById("downloadLink").href = url;
                        document.getElementById("downloadLink").download = `screen-recording-${new Date().toISOString()}.webm`;
                        document.getElementById("downloadLink").innerText = "Download Recording";
                        document.getElementById("downloadLink").style.display = "block";

                        // Cleanup
                        await cleanup();
                        
                        logger.info('Recording completed successfully');
                    } catch (error) {
                        logger.error('Error processing recording', error);
                        document.getElementById("recordingStatus").innerText = "Error processing recording";
                    }
                };

                // Start recording
                recorder.start(CHUNK_SIZE);
                recordingStartTime = Date.now();
                analytics.recordingsStarted++;
                
                // Update recording duration
                recordingInterval = setInterval(() => {
                    recordingDuration = Math.floor((Date.now() - recordingStartTime) / 1000);
                    const remainingTime = MAX_RECORDING_DURATION - recordingDuration;
                    
                    document.getElementById("recordingStatus").innerText = 
                        `Recording: ${Math.floor(recordingDuration / 60)}:${(recordingDuration % 60).toString().padStart(2, '0')} ` +
                        `(${Math.floor(remainingTime / 60)}:${(remainingTime % 60).toString().padStart(2, '0')} remaining)`;
                }, 1000);

                // Enable controls
                document.getElementById("startRecording").style.display = "none";
                document.getElementById("stopRecording").style.display = "inline-block";
                document.getElementById("markTime").disabled = false;

                // Handle stream end
                stream.getVideoTracks()[0].onended = () => {
                    if (recorder && recorder.state !== 'inactive') {
                        recorder.stop();
                    }
                };

                logger.info('Recording started successfully');
            } catch (error) {
                logger.error('Recording initialization error', error);
                await cleanup();
                document.getElementById("recordingStatus").innerText = "Failed to start recording";
                alert("Error: Unable to start recording. " + error.message);
            }
        });

        // Stop recording
        document.getElementById("stopRecording").addEventListener("click", function() {
            if (recorder && recorder.state !== 'inactive') {
                recorder.stop();
            }
        });

        // Mark time
        document.getElementById("markTime").addEventListener("click", function() {
            if (recorder && recorder.state === 'recording') {
                const marker = {
                    time: recordingDuration,
                    chunk: recordedChunks.length,
                    timestamp: new Date()
                };
                markers.push(marker);
                
                logger.info('Marker added', marker);
                document.getElementById("recordingStatus").innerText += " (Marker added)";
            }
        });

        // Close preview
        function closePreview() {
            document.querySelector(".floating-preview").style.display = "none";
        }

        // Add CSS for new features
        const style = document.createElement('style');
        style.textContent = `
            .preview-modal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            }

            .preview-content {
                background: var(--card-bg);
                padding: 20px;
                border-radius: 12px;
                max-width: 80%;
                max-height: 80%;
                overflow: auto;
            }

            .preview-controls {
                margin-top: 10px;
                display: flex;
                justify-content: space-between;
                gap: 10px;
            }

            .preview-controls button {
                flex: 1;
                padding: 10px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                color: white;
                transition: background 0.3s;
            }

            .preview-controls button:first-child {
                background: var(--button-bg);
            }

            .preview-controls button:last-child {
                background: var(--record-button);
            }

            #diskSpaceWarning {
                color: var(--record-button);
                margin-top: 10px;
                display: none;
            }
        `;
        document.head.appendChild(style);

        // Initialize the secondary panel
        async function initializeSecondaryPanel() {
            try {
                await soundboardManager.initialize();

                // Initialize soundboard buttons
                document.querySelectorAll('.sound-button').forEach(button => {
                    button.addEventListener('click', () => {
                        const soundKey = button.dataset.sound;
                        soundboardManager.playSound(soundKey);
                    });
                });

                // Initialize Bluetooth controls
                const bluetoothButton = document.getElementById('bluetoothConnect');
                const bluetoothStatus = document.querySelector('.bluetooth-status');

                bluetoothButton.addEventListener('click', async () => {
                    if (!bluetoothManager.isConnected()) {
                        bluetoothStatus.textContent = 'Connecting...';
                        bluetoothStatus.style.color = 'var(--text-color)';
                        
                        const connected = await bluetoothManager.connect();
                        
                        bluetoothStatus.textContent = connected ? 'Connected' : 'Connection failed';
                        bluetoothStatus.style.color = connected ? 
                            'var(--button-bg)' : 'var(--record-button)';
                        
                        bluetoothButton.textContent = connected ?
                            'Disconnect Bluetooth' : 'Connect Bluetooth Audio';
                    } else {
                        bluetoothManager.disconnect();
                        bluetoothStatus.textContent = 'Disconnected';
                        bluetoothStatus.style.color = 'var(--text-color)';
                        bluetoothButton.textContent = 'Connect Bluetooth Audio';
                    }
                });

            } catch (error) {
                logger.error('Error initializing secondary panel', error);
                document.querySelector('.secondary-panel').innerHTML = `
                    <div class="error-message">
                        Failed to initialize audio features: ${error.message}
                    </div>
                `;
            }
        }

        // Initialize the secondary panel when the document is ready
        document.addEventListener('DOMContentLoaded', initializeSecondaryPanel);
    </script>
</body>
</html>
